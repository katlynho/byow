# Build Your Own World

## Overview
In this project, I designed and implemented a 2D tile-based world exploration engine. By “tile-based”, I mean the worlds generated will consist of a 2D grid of tiles. By “world exploration engine” I mean that the software will build a world, which the user will be able to explore by walking around and interacting with objects in that world. The world also has an overhead perspective similar in style to the old Zelda video games.

With this project, I had learned how to manage and work with the large and complex code that comes with building a system like this. I also had the opportunity to create and design this from scratch, which was incredibly interesting, challenging, and insightful in regards to a future role as a software engineer. The difference between this project and every other course project that I had worked on was that there was no skeleton code given, just a general spec detailing what the end-result should do. Working without starter code for the very first time forced me to learn how to write code that "made sense", which meant moving code around into helper functions or other classes to make it cleaner and easier to understand. It also meant that I had to determine what subproblems to solve and in what order and what was the best data structure, algorithm, and methods to use. When working on the backend of the game, I was constantly asking questions along the lines of “What if we have this value be an ArrayList?” or “Would it be better to have this be a helper function? But then how would that affect the following code? Does it make sense to create a new class and API?” I had to ensure that the basic functionalities of the game worked as expected. 

When it came to designing the user-facing components, I had to think about what features the average user would want and need. In any game, users have the option to create a new game, continue from the previous game, quit their current game, and change their avatar, so I added those features in addition to allowing the user to replay all the moves they had taken during the game. To keep the game un-repetitive, I had worked on a method to randomly place the avatar in the world and created a way for the game to display different ‘worlds’ each time a user created a new game. These worlds would include rooms connected by straight and cornered hallways and walls surrounding these rooms and hallways. Each design decision was made in regards to what its goal was. Coding a world, room, hallway, wall, and allowed moves had to not only work but make sense and be efficient with respect to runtime and memory. The game features were designed based on the user and how our game can keep them engaged.

## The Game

